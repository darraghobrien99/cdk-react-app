"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeBuildSpecs = exports.BuildSpec = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const core_1 = require("@aws-cdk/core");
const yaml_cfn = require("./private/yaml-cfn");
/**
 * BuildSpec for CodeBuild projects.
 *
 * @stability stable
 */
class BuildSpec {
    /**
     * @stability stable
     */
    constructor() {
    }
    /**
     * @stability stable
     */
    static fromObject(value) {
        return new ObjectBuildSpec(value);
    }
    /**
     * Create a buildspec from an object that will be rendered as YAML in the resulting CloudFormation template.
     *
     * @param value the object containing the buildspec that will be rendered as YAML.
     * @stability stable
     */
    static fromObjectToYaml(value) {
        return new YamlBuildSpec(value);
    }
    /**
     * Use a file from the source as buildspec.
     *
     * Use this if you want to use a file different from 'buildspec.yml'`
     *
     * @stability stable
     */
    static fromSourceFilename(filename) {
        return new FilenameBuildSpec(filename);
    }
}
exports.BuildSpec = BuildSpec;
_a = JSII_RTTI_SYMBOL_1;
BuildSpec[_a] = { fqn: "@aws-cdk/aws-codebuild.BuildSpec", version: "1.101.0" };
/**
 * BuildSpec that just returns the input unchanged
 */
class FilenameBuildSpec extends BuildSpec {
    constructor(filename) {
        super();
        this.filename = filename;
        this.isImmediate = false;
    }
    toBuildSpec() {
        return this.filename;
    }
    toString() {
        return `<buildspec file: ${this.filename}>`;
    }
}
/**
 * BuildSpec that understands about structure
 */
class ObjectBuildSpec extends BuildSpec {
    constructor(spec) {
        super();
        this.spec = spec;
        this.isImmediate = true;
    }
    toBuildSpec() {
        // We have to pretty-print the buildspec, otherwise
        // CodeBuild will not recognize it as an inline buildspec.
        return core_1.Lazy.uncachedString({
            produce: (ctx) => core_1.Stack.of(ctx.scope).toJsonString(this.spec, 2),
        });
    }
}
/**
 * BuildSpec that exports into YAML format
 */
class YamlBuildSpec extends BuildSpec {
    constructor(spec) {
        super();
        this.spec = spec;
        this.isImmediate = true;
    }
    toBuildSpec() {
        return yaml_cfn.serialize(this.spec);
    }
}
/**
 * Merge two buildspecs into a new BuildSpec
 *
 * NOTE: will currently only merge commands, not artifact
 * declarations, environment variables, secrets, or any
 * other configuration elements.
 *
 * Internal for now because it's not complete/good enough
 * to expose on the objects directly, but we need to it to
 * keep feature-parity for Project.
 *
 * @internal
 */
function mergeBuildSpecs(lhs, rhs) {
    if (!(lhs instanceof ObjectBuildSpec) || !(rhs instanceof ObjectBuildSpec)) {
        throw new Error('Can only merge buildspecs created using BuildSpec.fromObject()');
    }
    return new ObjectBuildSpec(copyCommands(lhs.spec, rhs.spec));
}
exports.mergeBuildSpecs = mergeBuildSpecs;
/**
 * Extend buildSpec phases with the contents of another one
 */
function copyCommands(buildSpec, extend) {
    if (buildSpec.version === '0.1') {
        throw new Error('Cannot extend buildspec at version "0.1". Set the version to "0.2" or higher instead.');
    }
    const ret = Object.assign({}, buildSpec); // Return a copy
    ret.phases = Object.assign({}, ret.phases);
    for (const phaseName of Object.keys(extend.phases)) {
        const phase = ret.phases[phaseName] = Object.assign({}, ret.phases[phaseName]);
        phase.commands = [...phase.commands || [], ...extend.phases[phaseName].commands];
    }
    return ret;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVpbGQtc3BlYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJ1aWxkLXNwZWMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSx3Q0FBNkQ7QUFDN0QsK0NBQStDOzs7Ozs7QUFLL0MsTUFBc0IsU0FBUzs7OztJQTRCN0I7SUFDQSxDQUFDOzs7O0lBNUJNLE1BQU0sQ0FBQyxVQUFVLENBQUMsS0FBMkI7UUFDbEQsT0FBTyxJQUFJLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNwQyxDQUFDOzs7Ozs7O0lBT00sTUFBTSxDQUFDLGdCQUFnQixDQUFDLEtBQTJCO1FBQ3hELE9BQU8sSUFBSSxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbEMsQ0FBQzs7Ozs7Ozs7SUFPTSxNQUFNLENBQUMsa0JBQWtCLENBQUMsUUFBZ0I7UUFDL0MsT0FBTyxJQUFJLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3pDLENBQUM7O0FBckJILDhCQW1DQzs7O0FBRUQ7O0dBRUc7QUFDSCxNQUFNLGlCQUFrQixTQUFRLFNBQVM7SUFHdkMsWUFBNkIsUUFBZ0I7UUFDM0MsS0FBSyxFQUFFLENBQUM7UUFEbUIsYUFBUSxHQUFSLFFBQVEsQ0FBUTtRQUY3QixnQkFBVyxHQUFZLEtBQUssQ0FBQztJQUk3QyxDQUFDO0lBRU0sV0FBVztRQUNoQixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDdkIsQ0FBQztJQUVNLFFBQVE7UUFDYixPQUFPLG9CQUFvQixJQUFJLENBQUMsUUFBUSxHQUFHLENBQUM7SUFDOUMsQ0FBQztDQUNGO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLGVBQWdCLFNBQVEsU0FBUztJQUdyQyxZQUE0QixJQUEwQjtRQUNwRCxLQUFLLEVBQUUsQ0FBQztRQURrQixTQUFJLEdBQUosSUFBSSxDQUFzQjtRQUZ0QyxnQkFBVyxHQUFZLElBQUksQ0FBQztJQUk1QyxDQUFDO0lBRU0sV0FBVztRQUNoQixtREFBbUQ7UUFDbkQsMERBQTBEO1FBQzFELE9BQU8sV0FBSSxDQUFDLGNBQWMsQ0FBQztZQUN6QixPQUFPLEVBQUUsQ0FBQyxHQUFvQixFQUFFLEVBQUUsQ0FDaEMsWUFBSyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1NBQ2pELENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQUVEOztHQUVHO0FBQ0gsTUFBTSxhQUFjLFNBQVEsU0FBUztJQUduQyxZQUE0QixJQUEwQjtRQUNwRCxLQUFLLEVBQUUsQ0FBQztRQURrQixTQUFJLEdBQUosSUFBSSxDQUFzQjtRQUZ0QyxnQkFBVyxHQUFZLElBQUksQ0FBQztJQUk1QyxDQUFDO0lBRU0sV0FBVztRQUNoQixPQUFPLFFBQVEsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3ZDLENBQUM7Q0FDRjtBQUVEOzs7Ozs7Ozs7Ozs7R0FZRztBQUNILFNBQWdCLGVBQWUsQ0FBQyxHQUFjLEVBQUUsR0FBYztJQUM1RCxJQUFJLENBQUMsQ0FBQyxHQUFHLFlBQVksZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsWUFBWSxlQUFlLENBQUMsRUFBRTtRQUMxRSxNQUFNLElBQUksS0FBSyxDQUFDLGdFQUFnRSxDQUFDLENBQUM7S0FDbkY7SUFFRCxPQUFPLElBQUksZUFBZSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQy9ELENBQUM7QUFORCwwQ0FNQztBQUVEOztHQUVHO0FBQ0gsU0FBUyxZQUFZLENBQUMsU0FBYyxFQUFFLE1BQVc7SUFDL0MsSUFBSSxTQUFTLENBQUMsT0FBTyxLQUFLLEtBQUssRUFBRTtRQUMvQixNQUFNLElBQUksS0FBSyxDQUFDLHVGQUF1RixDQUFDLENBQUM7S0FDMUc7SUFFRCxNQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLGdCQUFnQjtJQUMxRCxHQUFHLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUUzQyxLQUFLLE1BQU0sU0FBUyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1FBQ2xELE1BQU0sS0FBSyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBQy9FLEtBQUssQ0FBQyxRQUFRLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQyxRQUFRLElBQUksRUFBRSxFQUFFLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUNsRjtJQUVELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElSZXNvbHZlQ29udGV4dCwgTGF6eSwgU3RhY2sgfSBmcm9tICdAYXdzLWNkay9jb3JlJztcbmltcG9ydCAqIGFzIHlhbWxfY2ZuIGZyb20gJy4vcHJpdmF0ZS95YW1sLWNmbic7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCdWlsZFNwZWMge1xuICBwdWJsaWMgc3RhdGljIGZyb21PYmplY3QodmFsdWU6IHtba2V5OiBzdHJpbmddOiBhbnl9KTogQnVpbGRTcGVjIHtcbiAgICByZXR1cm4gbmV3IE9iamVjdEJ1aWxkU3BlYyh2YWx1ZSk7XG4gIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICBwdWJsaWMgc3RhdGljIGZyb21PYmplY3RUb1lhbWwodmFsdWU6IHtba2V5OiBzdHJpbmddOiBhbnl9KTogQnVpbGRTcGVjIHtcbiAgICByZXR1cm4gbmV3IFlhbWxCdWlsZFNwZWModmFsdWUpO1xuICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcHVibGljIHN0YXRpYyBmcm9tU291cmNlRmlsZW5hbWUoZmlsZW5hbWU6IHN0cmluZyk6IEJ1aWxkU3BlYyB7XG4gICAgcmV0dXJuIG5ldyBGaWxlbmFtZUJ1aWxkU3BlYyhmaWxlbmFtZSk7XG4gIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IGlzSW1tZWRpYXRlOiBib29sZWFuO1xuXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcigpIHtcbiAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHB1YmxpYyBhYnN0cmFjdCB0b0J1aWxkU3BlYygpOiBzdHJpbmc7XG59XG5cbi8qKlxuICogQnVpbGRTcGVjIHRoYXQganVzdCByZXR1cm5zIHRoZSBpbnB1dCB1bmNoYW5nZWRcbiAqL1xuY2xhc3MgRmlsZW5hbWVCdWlsZFNwZWMgZXh0ZW5kcyBCdWlsZFNwZWMge1xuICBwdWJsaWMgcmVhZG9ubHkgaXNJbW1lZGlhdGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGZpbGVuYW1lOiBzdHJpbmcpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgcHVibGljIHRvQnVpbGRTcGVjKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZW5hbWU7XG4gIH1cblxuICBwdWJsaWMgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGA8YnVpbGRzcGVjIGZpbGU6ICR7dGhpcy5maWxlbmFtZX0+YDtcbiAgfVxufVxuXG4vKipcbiAqIEJ1aWxkU3BlYyB0aGF0IHVuZGVyc3RhbmRzIGFib3V0IHN0cnVjdHVyZVxuICovXG5jbGFzcyBPYmplY3RCdWlsZFNwZWMgZXh0ZW5kcyBCdWlsZFNwZWMge1xuICBwdWJsaWMgcmVhZG9ubHkgaXNJbW1lZGlhdGU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBzcGVjOiB7W2tleTogc3RyaW5nXTogYW55fSkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBwdWJsaWMgdG9CdWlsZFNwZWMoKTogc3RyaW5nIHtcbiAgICAvLyBXZSBoYXZlIHRvIHByZXR0eS1wcmludCB0aGUgYnVpbGRzcGVjLCBvdGhlcndpc2VcbiAgICAvLyBDb2RlQnVpbGQgd2lsbCBub3QgcmVjb2duaXplIGl0IGFzIGFuIGlubGluZSBidWlsZHNwZWMuXG4gICAgcmV0dXJuIExhenkudW5jYWNoZWRTdHJpbmcoe1xuICAgICAgcHJvZHVjZTogKGN0eDogSVJlc29sdmVDb250ZXh0KSA9PlxuICAgICAgICBTdGFjay5vZihjdHguc2NvcGUpLnRvSnNvblN0cmluZyh0aGlzLnNwZWMsIDIpLFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQnVpbGRTcGVjIHRoYXQgZXhwb3J0cyBpbnRvIFlBTUwgZm9ybWF0XG4gKi9cbmNsYXNzIFlhbWxCdWlsZFNwZWMgZXh0ZW5kcyBCdWlsZFNwZWMge1xuICBwdWJsaWMgcmVhZG9ubHkgaXNJbW1lZGlhdGU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBzcGVjOiB7W2tleTogc3RyaW5nXTogYW55fSkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBwdWJsaWMgdG9CdWlsZFNwZWMoKTogc3RyaW5nIHtcbiAgICByZXR1cm4geWFtbF9jZm4uc2VyaWFsaXplKHRoaXMuc3BlYyk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gYnVpbGRzcGVjcyBpbnRvIGEgbmV3IEJ1aWxkU3BlY1xuICpcbiAqIE5PVEU6IHdpbGwgY3VycmVudGx5IG9ubHkgbWVyZ2UgY29tbWFuZHMsIG5vdCBhcnRpZmFjdFxuICogZGVjbGFyYXRpb25zLCBlbnZpcm9ubWVudCB2YXJpYWJsZXMsIHNlY3JldHMsIG9yIGFueVxuICogb3RoZXIgY29uZmlndXJhdGlvbiBlbGVtZW50cy5cbiAqXG4gKiBJbnRlcm5hbCBmb3Igbm93IGJlY2F1c2UgaXQncyBub3QgY29tcGxldGUvZ29vZCBlbm91Z2hcbiAqIHRvIGV4cG9zZSBvbiB0aGUgb2JqZWN0cyBkaXJlY3RseSwgYnV0IHdlIG5lZWQgdG8gaXQgdG9cbiAqIGtlZXAgZmVhdHVyZS1wYXJpdHkgZm9yIFByb2plY3QuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUJ1aWxkU3BlY3MobGhzOiBCdWlsZFNwZWMsIHJoczogQnVpbGRTcGVjKTogQnVpbGRTcGVjIHtcbiAgaWYgKCEobGhzIGluc3RhbmNlb2YgT2JqZWN0QnVpbGRTcGVjKSB8fCAhKHJocyBpbnN0YW5jZW9mIE9iamVjdEJ1aWxkU3BlYykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IG1lcmdlIGJ1aWxkc3BlY3MgY3JlYXRlZCB1c2luZyBCdWlsZFNwZWMuZnJvbU9iamVjdCgpJyk7XG4gIH1cblxuICByZXR1cm4gbmV3IE9iamVjdEJ1aWxkU3BlYyhjb3B5Q29tbWFuZHMobGhzLnNwZWMsIHJocy5zcGVjKSk7XG59XG5cbi8qKlxuICogRXh0ZW5kIGJ1aWxkU3BlYyBwaGFzZXMgd2l0aCB0aGUgY29udGVudHMgb2YgYW5vdGhlciBvbmVcbiAqL1xuZnVuY3Rpb24gY29weUNvbW1hbmRzKGJ1aWxkU3BlYzogYW55LCBleHRlbmQ6IGFueSk6IGFueSB7XG4gIGlmIChidWlsZFNwZWMudmVyc2lvbiA9PT0gJzAuMScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBleHRlbmQgYnVpbGRzcGVjIGF0IHZlcnNpb24gXCIwLjFcIi4gU2V0IHRoZSB2ZXJzaW9uIHRvIFwiMC4yXCIgb3IgaGlnaGVyIGluc3RlYWQuJyk7XG4gIH1cblxuICBjb25zdCByZXQgPSBPYmplY3QuYXNzaWduKHt9LCBidWlsZFNwZWMpOyAvLyBSZXR1cm4gYSBjb3B5XG4gIHJldC5waGFzZXMgPSBPYmplY3QuYXNzaWduKHt9LCByZXQucGhhc2VzKTtcblxuICBmb3IgKGNvbnN0IHBoYXNlTmFtZSBvZiBPYmplY3Qua2V5cyhleHRlbmQucGhhc2VzKSkge1xuICAgIGNvbnN0IHBoYXNlID0gcmV0LnBoYXNlc1twaGFzZU5hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgcmV0LnBoYXNlc1twaGFzZU5hbWVdKTtcbiAgICBwaGFzZS5jb21tYW5kcyA9IFsuLi5waGFzZS5jb21tYW5kcyB8fCBbXSwgLi4uZXh0ZW5kLnBoYXNlc1twaGFzZU5hbWVdLmNvbW1hbmRzXTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59Il19